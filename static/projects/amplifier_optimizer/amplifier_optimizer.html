<div class="amplifier-optimizer">
    <h1>Amplifier Optimizer</h1>
  
    <div style="width:100%; height:0; padding-top:62.4%; position:relative;">
      <img 
        alt="Circuit Schematic" 
        src="/api/projects/amplifier_optimizer/circuit.png" 
        style="position:absolute; top:0; left:0; width:100%;">
    </div>
  
    <h2>Summary</h2>
  
    <p>
      Ever gotten a homework assignment and immediately written it off as a loss? 
      <br><br>
      Optimizing this cascaded BJT amplifier was one of those for me. Calculating the 
      charactaristics of a given amplifier is relatively straight forward, but taking a set of 
      desired parameters and turning it into a design is another matter. Interestingly though, the 
      issue is not a lack of knobs to turn -- it's that changing one of them influences the impact
      of a change in another. Asking my professor for guidence got me a frustrating answer: try 
      different combinations until you find one that works.
      <br><br>
      I don't know about you, but that sounds like computer work to me. There are a number of ways
      to tackle a search problem like this. A simple grid search would probably work fine, and a 
      baysian search might work a little better. If you want the "wow" factor though, you use a 
      <a href="https://en.wikipedia.org/wiki/Genetic_algorithm" >genetic algorithm</a>.
    </p>
  
    <h2>The Solution</h2>
  
    <p>
      The most efficient way to solve a problem like this would be analytically as a system of 
      equations. Being motivated by laziness, however, that solution won't suffice. A black box 
      optimization strategy like a genetic algorithm may not have the shortest run time, but our
      goal is to minimize study time. 
      <br><br>
      Genetic algorithms are fairely intuitive optimizers. Given some function and a "loss 
      function" describing the desired output, a genetic algorithm first randomly generates a set
      of possible inputs. For this use case, the inputs are the resistor and Vcc values. The code
      below shows how I randomly generate the inputs according to a configurable probability 
      distribution.
    </p>
    <pre>
      <code>
void Amplifier::Randomize() {
  // Randomizes the amplifier.

  // Set up random number generation.
  std::random_device rd;  // Get random number from hardware.
  std::mt19937 eng(rd());  // Seed the generator.
  // Define Distributions.
  std::uniform_int_distribution<> 
    resistor_distribution(0, max_resistor);
  std::uniform_int_distribution<> 
    Vcc_distribution(1, max_Vcc);

  // Set random Vcc and resistor values.
  Vcc = Vcc_distribution(eng);
  R1 = resistor_distribution(eng);
  R2 = resistor_distribution(eng);
  R3 = resistor_distribution(eng);
  R4 = resistor_distribution(eng);
  Rc1 = resistor_distribution(eng);
  Re1 = resistor_distribution(eng);
  Re2 = resistor_distribution(eng);
}
      </code>
    </pre>
    
    <p>
      After a population of inputs is randomized, each set is passed through a function and the
      results are ranked in order from best to worst according to the loss function. In our case,
      the function is a set of BJT amplifier equations and the loss function is a combination of
      amplifier charactaristics. The code block below shows the process of calculating the voltage
      gain of the amplifier (one of the many variables that a user may want to optimize for).
    </p>

    <pre>
      <code>
//Av-----------------------------------

void Amplifier::calculate_Av() {
  Av = Avs * Av1 * Av2;
}

void Amplifier::calculate_Avs() {
  Avs = Rin / (parameters::Rsource + Rin);
}

void Amplifier::calculate_Av1() {
  double beta = parameters::beta;
  double Rload = parameters::Rload;
  double numerator;
  double denominator;
  // numerator = (Rc1||Rth2||(Rpi2 + (beta + 1)(Re2||Rload)
  numerator = beta * 
    1 / (1/Rc1 + 1/Rth2 + 1/(Rpi2 + (beta + 1) * 
    1 / (1/Re2 + 1/Rload)));
  denominator = Rpi1;
  Av1 = numerator / denominator;
}

void Amplifier::calculate_Av2() {
  double beta = parameters::beta;
  double Rload = parameters::Rload;
  double numerator;
  double denominator;
  // numerator = (beta + 1)(Re2||Rload)
  numerator = (beta + 1) * 1 / (1/Re2 + 1/Rload);
  denominator = Rpi2 + (beta + 1) * 1 / (1/Re2 + 1/Rload);
  Av2 = numerator / denominator;
}
      </code>
    </pre>

    <p>
      The poor performers are then removed from the population, and an equal number of new specimens
      are generated by randomly tweaking the most sucessful inputs. The snippet below shows the
      process of generating these new amplifier parameters. 
    </p>

    <pre>
      <code>
void mutate(const Amplifier &amp, Amplifier &new_amp) {
  // Takes an Amplifier and returns a new amplifier modified from the 
  // one provided.
    
  std::uniform_real_distribution<>  // Define Distribution.
    mutation_distribution((-1)*parameters::max_mutation, 
                              parameters::max_mutation);
  
  // Set new Vcc and resistor values.
  double new_Vcc = (1 + (double) mutation_distribution(eng)) * 
    amp.get_Vcc();
  new_Vcc = std::min(new_Vcc, parameters::max_Vcc);
  new_Vcc = std::max(new_Vcc, parameters::min_Vcc);
  new_amp.set_Vcc(new_Vcc);

  new_amp.set_R1(std::min((1 + (double) mutation_distribution(eng)) * 
    amp.get_R1(), parameters::max_resistor));
  new_amp.set_R2(std::min((1 + (double) mutation_distribution(eng)) * 
    amp.get_R2(), parameters::max_resistor));
  new_amp.set_R3(std::min((1 + (double) mutation_distribution(eng)) * 
    amp.get_R3(), parameters::max_resistor));
  new_amp.set_R4(std::min((1 + (double) mutation_distribution(eng)) * 
    amp.get_R4(), parameters::max_resistor));
  new_amp.set_Rc1(std::min((1 + (double) mutation_distribution(eng)) * 
    amp.get_Rc1(), parameters::max_resistor));
  new_amp.set_Re1(std::min((1 + (double) mutation_distribution(eng)) * 
    amp.get_Re1(), parameters::max_resistor));
  new_amp.set_Re2(std::min((1 + (double) mutation_distribution(eng)) * 
    amp.get_Re2(), parameters::max_resistor));
}
      </code>
    </pre>

    <p>
      Repeating this process enough times results in a population selectively "bred" from the top
      performing amplifiers. Once the top performing amplifier in a population meets the target
      criteria, the process can be stopped.
    </p>
  
    <h2>Conclusion</h2>
  
    It worked! 
    <br><br>
    After a few seconds, this algorithm had generated an amplifier fitting my teacher's
    criteria. In fact, after a few minutes, it was able to surpass her expectations in terms of maximum
    voltage swing and low power draw. A custom analytical solution would run much faster, but I got
    an 'A' and a few bonus points for this so there was never any need. If you're curious about the
    rest of the code or would like to do something similar yourself, feel free to check out the full
    source code on my <a href="https://github.com/busyboredom/AmplifierOptimizer/">GitHub</a>.
  
    <p class="feedback">
      <i>See a bug or typo?</i> <a onclick="window.busy.contact()">Contact Me</a>
    </p>
  
  </div>
  <style>
  .amplifier-optimizer {
    max-width: 80ch;
    margin: 0 auto;
    padding: 0 1em;
  }
  
  img {
    max-width:100%;
  }
  
  </style>
